<h2>About the improvements to this blog</h2>
<p>From the beginning, I implemented the design and functionality of this blog from scratch. No blogging platforms, frameworks, or libraries were used; I only used plain HTML, CSS, and Javascript using only standard Web APIs. This blog is hosted by Github pages, which only hosts static websites so everything you see here, from the loading of blog entries to the page transition effects are all done through front-end code.</p>
<p>I am sure I am not the only one who applies what I learn in web development to the improvement of my blog. This blog started out with an animated background using a looping webm video element styled to occupy the viewport and positioned behind every other element. The colors were specified using color names instead of any specific hex color values, and the Javascript used older language syntax and older standard API features for downloading and displaying the blog entries.</p>
<p>The problems were that there was no way to stop the animated background and the contrast of the black background with the white text were too contrasting to comfortably read. The dark red links were also difficult to see on mobile device screens. At the very least though, the website was minimally responsive: the content would wrap to fit in smaller screens.</p>
<p>Later on I added a button to disable the animated background. I also added a button for toggling between a light theme and a dark theme, with the option saved in local storage so that the settings would not be reset if the user refreshes or closes the page.</p>
<p>As of the past couple weeks, I've accelerated my learning in web development and decided to improve everything about the blog. Starting with CSS, the aesthetic improvements include fine tuning the colors and the space between elements for a more comfortable reading experience so much so that a light theme is not necessary. But that is just for starters. The real improvements reside in the Javascript which include: use of document fragments, event listeners, async/await, promises, the Fetch API, smooth page transitions, and loading spinners.</p>
<p>First on document fragments, these represent a hierarchy of HTML elements like the document object. Document fragments can have their DOM be manipulated and when ready, a document fragment can be inserted into a document element resulting in the document fragment's child nodes being inserted into the document. This is the preferred way to dynamically insert content in a document. It is better than inserting nodes into a document one at a time which results in the layout visually changing in the viewport after every insertion. In addition to use document fragments to build the content of a blog entry under one parent element before displaying it, I now also use document fragments to save 2 fragments which may be used later, potentially multiple times: a document fragment for an error message indicating that a page failed to load, and a document fragment containing an animated loading spinner which gets displayed while a page takes longer than 300ms to load.</p>
<p>In many web development philosophies including those from &ldquo;responsive design&rdquo; and &ldquo;progressive web apps&rdquo;, a loading animation should always be shown while data is loading so that the user knows that something is happening. The loading spinner I used, I took from loading.io that contains advanced CSS animation code for loading spinner HTML elements. Their CSS code used pixel units in their animations with fixed colors so I modified it to use em units which scale better with screen and font size and I used my own colors specified through root css variables. After successfully implementing a loading spinner on the blog, I realized that it's a waste of time to show a loading spinner only to immediately remove it in place of the requested content for users who have fast and stable connections: if often results in an undesirable page stutter where you see the loading spinner for less than half a second followed by the content immediately. It's jarring. So what I've decided to do was put a timer on the page fetch and only display the loading spinner if the fetch started to take longer than 300ms. </p>
<p>To test it, I had to make modified fetch function that introduced a simulated delay before performing the real fetch. The delayed fetch function is now implemented by waiting on 2 promises to complete, the first promise being the real fetch and the second promise being a delay that resolves itself through a callback set from setTimeout. The delayed fetch function returns the result of the first promise while discarding the second promise result.</p>
<p>The results are better but there are still page jumps or stutter effects that happen due to the DOM insertion of document fragments even if the data downloads fast and the fragments are constructed fast. I decided to look into smooth page transitions. The easiest transition to do is just a simple fade-out and fade-in effect. I decided to have the main content fade-out when a link is clicked and fade-in with the new content only after the new content is downloaded, constructed, and inserted into the document. CSS is responsible for the fading effects while Javascript is responsible for triggering it and synchronizing itself with the animation durations so as not to interrupt them, this interruption prevention could not have been possible without well placed <i>await</i> expressions on asynchronous operations. The difficult thing was to also fade-in with the loading spinner after a threshold time and fade that out in place of the fetched content; if the threshold time for the loading spinner never occurs, then the loading spinner timer had to be cancelled and the content faded-in instead.</p>
<p>The results are amazing and smooth except for one last thing. The scrollbar would shift the position of the entire document if going from a page without a scrollbar to a page that does have one. The solution I found on css-tricks.com was to add a left margin to the root element equal to <code>calc(100vw - 100%);</code> which is the difference in length of the viewport width to the length of the document width which equals the width of the scrollbar. By offsetting the left margin of the document equal to the width of the scrollbar, the document will never shift because the scrollbar will now be on top of the right side of the document instead of to the right of it. The side-effect is that the document is slightly unbalanced to the right because of the added margin, this can result in trimmed off text if your content doesn't have ample padding.</p>
<p>Another improvement to the Javascript that I forgot to mention was to execute all the Javascript on the 'DOMContentLoaded' event on the window, this basically means that the Javascript would execute after the HTML was loaded but without waiting for the CSS to load.</p>
<p>The result is a smooth and responsive blog that works without any backend code. I know that these last 3 entries are about technical things, I will hopefully make more entries about gaming and game design with their philosophical twists.</p>

