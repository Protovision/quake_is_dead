<h1>Language design</h1>
<figure>
	<blockquote>
		<p>Let me try to explain to you, what to my taste is characteristic for all intelligent thinking. It is, that one is willing to study in depth an aspect of one's subject matter in isolation for the sake of its own consistency, all the time knowing that one is occupying oneself only with one of the aspects.</p>
		<figcaption>Edsger W. Dijkstra</figcaption>
	</blockquote>
</figure>
<p>My absence of writing on this blog has been caused simultaneously by personal life events and personal work (work for myself, not others) as well as my personal struggle to find employment that is relevant to who I am. The origin of this blog lay in my entrapment and disillusionment of the gaming industry, I had and still do wish to create something better. On this journey, a stepping stone includes the creation of a new programming language which has become a path bigger than it's motivational purpose, it became a motivation in itself.</p>
<p>I have left the world of gaming, lest I become like a wallowing spiteful dwarf who endlessly complains about the small city or the small swamp without taking the leap to leave and venture into the bigger world up into bigger mountains where those problems fade off beneath the thick white clouds of frost and the horizon becomes clear where inspirations strike like the lightning and glow like the sun. I have realized the difference between hate and ressentment.</p>
<p>The initial designs for it is coming together and I will not lay out syntactic details for it here until a first working prototype is made. Something new yet something familiar, consistent, practical, straightforward, and efficient have all been the guiding aspects of this design. These affirmatives coupled with their anti-affirmative inspirations: to get away from a brewing madness in the programming languages of the 2010's that can only be born of weakness and stupidity: ever more runtime checking and management and more restrictive compile-time security. People today want to give up freedom and power for security and one-size-fits-all curated features, the former is born of a severe lack of self-commanding will and the latter is born of lack of focus and strength to choose for oneself.</p>
<p>You can see this when people use buzzwords in technology and flock to them blindly without understanding why they even need to use it in their projects. Popularity does not equal utility for oneself. Popularity can be perceived and overhyped and everyone may mention it to not appear out of the loop but no one actually uses it in practice. If someone walks and talks intelligently and endorses a certain product in a way that superficially sounds intelligent but at bottom is nothing but fluff and con-artistry, I will detect it.</p>
<!--
<p>Rust is the 1990's Java of the 2010's, everyone loves to show appreciation for it but nobody actually uses it and enjoys it except for the submissive sadomasochists. I will never understand the joys of a compiler that constantly busts your balls and never lets you take the rubber off.</p>
-->
<p>The language I am thinking of for myself has one compilation target: WebAssembly. And keeping with the minimalism of WebAssembly, this language shall not have standard I/O for this is domain-specific and this language shall be domain-agnostic, making it more general purpose, not just across domains but also across platforms. It may not be the case that programs in this language shall execute within web browsers, they may execute on host environments running on embedded devices and so performance is an important aspect here.</p>
<p>Unlike most languages today, this language shall not have a garbage collector or automatic reference counting, it will not even have a dynamic memory allocator. Two memory segments it shall manage though: static data (for globals and constants) and stack data (for locals).</p>
<p>In the spirit of C, this language shall support simple and direct constructs for which the generated WebAssembly can be easily envisioned with zero-overhead costs. Also in the spirit of C, the type system shall be weak but also implicit and structural. Contrary to this, modern compiled programming languages today are strongly typed, explicit, and nominal in their typing. I find these to be overly restrictive and while I understand that a systems language requires you to be careful, it should not force you to be and it should never assume that it is more intelligent than the user. The user should be trusted but I often find today that programmers cater to and expect stupidity from other programmers while preaching doctrines that award complete ignorance of reality so as to uphold portability and avoid "undefined behavior".</p>
<p>This term, "undefined behavior" is a label used to control other people's behavior when it comes to engineering. "Oh that's UB so you can't do that" even though it's been done and it's been working for the last 40 years. "Oh it's just a coincidence that this system uses IEEE 754 for floating-points, you shouldn't assume that." How absurd! The same people who say that cannot name one system that doesn't use IEEE 754 in the history of computing which is ironic considering how hellbent they are on imposing standards on everyone, so the one time all computers adhere to a single standard, they are still not satisfied that you are putting good faith in it like they are because deep down inside they want no other to be as pious as them.</p>
<p>Type punning is another large propaganda ridden subject around the UB and IB doctrines. I believe it is an insult to one's intelligence when someone tells you that type punning is always bad and instead endorses you to use some "magic" feature that takes care of the ugly details for you to acheive the same effect even though the generated assembly looks exactly the same. If someone tells you to stick to an abstraction and dissaudes you from interacting with reality, they are implcitly telling you that you are too weak and too stupid for the truth. You often find that it is the Microsoft-loyalist programmers who will preach to you their virtues and write endless blog posts, wikipedia article edits, and make videos on the subjects of blissful ignorance programming: even within systems programming.</p>
<p>The truth of type punning: it works when the following 3 conditions are met: both types have the same size, both types have the same alignment, both types have parallel sequences of padding bits (or no padding at all). (endianness should also be deliberate here). But apparently programmers are too stupid to be trusted to remember these 3 basic facts according to language lawyers.</p>
<p>My language shall have a dedicated type punning operator that will allow you to cast between any types that meet these conditions. Danger shall be the primary virtue of this language that I call My Word and the tablet of safety shall be broken in front of the worshippers of the all-seeing rainbow.</p>
<p>Other features of this language include multiple return values of functions, literal expressions for aggregate types, modules, and structured multi-nested branching.</p>
<p>Modules are especially important and are only a natural feature that is already supported by WebAssembly. The module system should be simple with a very clear and stable ABI. The ABI shall simply adhere to the following: Since WebAssembly functions can only accept arguments of scalar type, then all aggregate type arguments are implicitly passed by reference. Since WebAsembly functions can only return 1 value as of version 1.0, they shall instead return a reference to a tuple if they return multiple values. I would also like a way for function callers to set up a memory region for called functions to directly initialize their results into rather than having functions set up a return value(s) in their local stack space only to have it moved into the local stack space of the calling function when returning; it is a redundant form of data copying.</p>
<p>Structured branching where code can branch multiple levels up from a code block, which is already supported in WebAssembly, will of course be supported in this language. It is a more organized and sane derivative of using goto statements while still retaining much of the power.</p>
<p>Object oriented programming shall not be supported, instead modularity through the organization of entities within modules and namespaces together with procedural programming shall be sufficient. Because what is object-oriented programming besides calling free functions while passing a reference to the object as a first argument? Inheritance and polymorphism are rarely if ever needed and can be simulated anyways using tagged structures. I do not believe in having language features that have runtime cost for this language.</p>
<p>The closest thing to functional programming in this language would be the ability to create anonymous functions (even recursive ones) on the fly while having functions be treated as first-class types. Perhaps this is even enough to be counted as supporting functional programming, but it is not a feature that shall be the only one true way to make programs.</p>
<p>I recently watched a video of a short lecture Brian Kernighan gave in 2015 on programming language design. Altough I have great respect for him, I believe his recommendations do not apply to me. He advocated the design of small domain-specific languages with more narrow purposes (such as awk, sed, pic, markdown) rather than more general purpose languages. One of two reasons for this prescription: he believes his audience were not smart enough to create a real programming language, or he himself was not good enough to create a real programming language that was as successful and popular as C and thus his envy leaks out against Thompson and the late Ritchie.</p>
<p>If the former is true, then it is the same teaching pattern of computer science that has led up to what we have now: endless leaky abstractions and an abundance of blue pilled matrix users. Details are now forgotten. Who actually knows how to properly implement a dynamic array today after 5 years of a CS degree, after 10 years?</p>
<p>If the latter is true, then the domain of computer science is about obscurity of knowledge and political impediments of innovation for professional job safety from unions and market monopolization lockdown from big tech working together for a transactionary mutual benefit and equilibrium at the cost of future generations, leading to massive unemployment and outsourcing and an ultimate degradation of the quality of software and electronics in general which may even cost lives. But this conclusion may be drawn from the former as well. The cause, being either ignorance or malice, is not relevant.</p> 


